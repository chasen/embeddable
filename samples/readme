There are now two controller routes for handling media

1) /api/media/fetch

This route is what we use in the FamilyShare CMS admin for uploading media. It accepts either an uploaded file or a URI and returns a media object. If a file is provided, it uploads it to the media library. If a URI is provided, it looks at the domain name and decides on the best provider definition for fetching the metadata for the URI.

Depending on the provider, it then either does an open-graph query or an oembed query to get the metadata for the URI. It then takes the metadata, normalizes it to a standard schema, and saves it to the "data" portion of the entry response. If a photo_url was set in the response data, it then uploads the photo to our media library and saves the returned media-lib metadata in the "media" portion of the media object.

The system accepts ALL types of URI's now. It used to only accept images and youtube videos, but that has changed with the new inline-social code. Not only can use a URI to any .png, .gif, .jpg image file, but you can now also use a URI to any website, including sites such as Facebook, Twitter, YouTube, Vimeo, Giphy, Pinterest, or any news or blog site.

If you use a URI to a web page, it will fetch the open-graph data provided by that page and use it for the "data" portion of the media object, and will take any provided photo_url and upload that to the media library.

For example, if you call this with a YouTube URI, it will call YouTube and fetch the metadata as "data", and will upload the thumbnail image provided in the "data" to the media library.

Here is an example of what the returned media object looks like:

entry = {
  // This is the URI or Filename of the source
  uri: 'http://domain/path',

  // This is the photo metadata provided by our media library.
  media: {
    url: 'https://media.deseretdigital.com/file/f859740277',
    id: 12345,
    hash: 'f859740277',
    type: 'image/jpeg',
    width: 400,
    height: 600,
    client: 2,
    size: 183391
  },

  // This is the provider that was identified for the uri
  provider: 'default',           (Provider name)

  // This will only be set if there was an error fetching the data
  error: 'Error String'          (Provider error)

  // This is the metadata fetched by the provider for the uri
  data: {                        (Provider data)
    type: 'article',
    title: 'Article title',
    description: 'Description',

    author_url: 'http://',
    author_name: 'Name',

    provider_url: 'http://',
    provider_name: 'Name',

    photo_url: 'http://',
    photo_type: 'jpg',
    photo_width: 300,
    photo_height: 400,

    embed_url: 'http://',
    embed_tag: 'iframe',
    embed_type: 'flash',
    embed_width: 300,
    embed_height: 400,
    embed_html: '<html></html>'
  }
 };

This is different from what the the media entries used to look like. Here is what they looked like before my upgrade tonight:

entry = {
  image: 'https://media.deseretdigital.com/file/f859740277',
  id: 12345,
  hash: 'f859740277',
  type: 'image/jpeg',
  width: 400,
  height: 600,
  client: 2,
  size: 183391,
};

You will notice that all of this information is now contained in the "media" portion of the entry, and what was the "image" property is now called "url". I made this change because the media entry used to only represent images (and occasionally youtube videos). The media entry is now a general purpose container for all types of media and accepts any URI. Instead of handling only images, the media object now contains images, iframe embeds, titles, authors, etc...

2) /api/media/render

This route is what you use to render a media entry to HTML. It accepts two JSON-encoded properties: "media" and "opts" in the body of the request.

The "media" property is either a single media entry (generated via /api/media/fetch), or an array of media entries. The array is useful if you want to batch render an entire array of entries in one call.

The "opts" property is an object that specifies how to render the entry (or entries). If no opts is provided, default values will be used to generate the rendered output.

Here is an example of possible opts properties:

{
  // This specifies what type of HTML output you want
  // 'auto' is the default
  as: 'auto' | 'photo' | 'rich' | 'title' | 'embed' | 'link',

  // This specifies whether you want to render errors as HTML output
  // false is the default
  errors: true | false,

  // If this is set to true, then it won't try to render embedded output
  // false is the default
  noembed: true | false,

  // If this is set to true, the output will be wrapped in a div:
  // <div class="embed-block embed-<style>"> HTML </div>
  // false is the default
  block: true | false,

  // This will be used in the block <div> and appended to "embed-" as a class
  style: 'name',

  // This specifies the output dimensions of the photo rendering.
  // If a string name is provided, it will be looked up in the global
  // system options (see system/options/defaults/renditions.yaml).
  // If an object is provided, a width and a height can be directly specified.
  rendition: 'name' | { width: 600, height 480 },

  // This will crop the image to these specifications
  // If this value isn't provided, the rendition name will be used to
  // find crop data inside the media object in media.renditions[rendition_name].
  // So instead of setting crop data here, you can put it inside the media entry.
  // This is how all the crop information for images in the CMS are stored.
  crop: { top: 0, left: 0, width: 400, height: 500 },

  // If set to true, links will have nofollow attributes set
  // false is the default
  nofollow: true | false,

  // If set to true, links will spawn a new window when clicked
  // false is the default
  popup: true | false,

  // When set to an article id, this provides links the ability to track
  // where they were clicked.
  from_id:
}

Here is an example of a minimum set of opts properties you can pass to render images for the quiz (asuming you have defined a quiz rendition in the server/options/defaults/renditions.yaml). It also assumes that any crop information is passed in the media entry itself as media.renditions[name].

{
  as: 'photo',
  rendition: 'quiz'
}
